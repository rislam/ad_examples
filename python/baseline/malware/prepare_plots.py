import numpy as np
import matplotlib
# matplotlib.use('Agg')
import time
from common.utils import *
import matplotlib.pyplot as plt
from baseline.malware.baseline_util import *
from baseline.malware.baseline_experiments import process_options
from os import listdir
from os.path import isfile, join
from numpy import genfromtxt

def collect_results(opts, adr=False, f1=False, queried=False):
    if f1 is True:
        key = "f1.txt"
    elif adr is True:
        key = "adr.txt"
    elif queried is True:
        key = "queried.txt"
    res_dir = os.path.join(opts.save_results_location, opts.prefix)
    result_files = [f for f in listdir(res_dir) if isfile(join(res_dir, f)) and key in f]
    # print (result_files)

    if f1 is True or adr is True:
        map_mean = {}
        map_std = {}
        print("#of files ", len(result_files))
        for file in result_files:
            act_loc = os.path.join(res_dir, file)

            n_key = len(opts.prefix)
            key = file.replace(".txt", "")[n_key + 1:]
            print(key)
            r = genfromtxt(act_loc, delimiter=',')
            # print (r)
            # print(r.shape)
            mean = np.mean(r, axis=0)
            std = np.std(r, axis=0)

            if key not in map_mean.keys():
                map_mean[key] = mean
            if key not in map_std.keys():
                map_std[key] = std
            # print("mean ", mean, " std", std)
            # break
        # print (map_mean.keys(), map_std.keys())
        return map_mean, map_std


def plot_map(opts, result_map, std_map=None, f1=False, adr=False):
    print("inside plot map")
    starting_yr = 2012
    ending_yr = 2017
    if f1 is True:
        suffix = "-f1"
        title = "F1 Score across years"
        y_label = "F1 Score"
        x_label = "Years"
    elif adr is True:
        suffix = "-adr"
        title = "Detection Rate across years"
        y_label = "Detection Rate"
        x_label = "Years"
    keys = result_map.keys()

    for s_yr in range(starting_yr, ending_yr):
        plt_keys = list()
        plt_values = list()
        plt_stds = list()

        for e_yr in range(s_yr, ending_yr):
            res_key = str(s_yr) + "_" + str(e_yr) + suffix
            if res_key in keys:
                print(res_key, result_map[res_key])
                n_key_res = len(result_map[res_key])
                plt_keys.append(res_key.replace(suffix, "").split("_")[1])
                plt_values.append(result_map[res_key])
                plt_stds.append(std_map[res_key])
        print(plt_keys, plt_values, len(plt_keys))
        objects = plt_keys
        y_pos = np.arange(len(objects))
        performance = plt_values
        ax = plt.subplot(111)
        w = 0.1
        plt_values_np = np.array(plt_values)
        plt_stds_np = np.array(plt_stds)
        print(plt_values_np, plt_stds_np)

        ax.errorbar(y_pos, plt_values_np[:, 0], yerr=plt_stds_np[:, 0])
        print(plt_values_np[:, 0])
        plt.xticks(y_pos, objects)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        plt.title(title + "-" + str(s_yr))
        # plt.show()
        plt.savefig(os.path.join("./results", opts.prefix + "-" + str(s_yr) + suffix + ".pdf"))
        plt.close()


def plot_feedback(opts, result_map, std_map=None, f1=False, adr=False, adapt=False):
    print("inside plot feedback")
    starting_yr = 2012
    ending_yr = 2017
    if f1 is True:
        suffix = "-f1"
        title = "F1 Score change with feedback for "
        y_label = "F1 Score"
        x_label = "Amount of Feedback (%)"
    elif adr is True:
        suffix = "-adr"
        title = "Detection Rate change with feedback for "
        y_label = "Detection Rate"
        x_label = "Amount of Feedback (%)"
    keys = result_map.keys()
    print(keys)

    if adapt is True:
        plt_keys = list()
        plt_values = list()
        plt_stds = list()
        for s_yr in range(starting_yr, ending_yr):
            fair_key = str(s_yr) + "_" + str(s_yr) + "_fair_eval" + suffix
            data = result_map[str(s_yr) + "_" + str(s_yr) + suffix][0]
            plt_values.append(np.insert(result_map[fair_key], 0, data))
            plt_stds.append(np.insert(std_map[fair_key], 0, 0))
            plt_keys.append(str(s_yr) + "-fair")

            optmst_key = str(s_yr) + "_" + str(s_yr) + "_optmst_eval" + suffix
            plt_values.append(np.insert(result_map[optmst_key], 0, data))
            plt_keys.append(str(s_yr) + "-optmst")
            plt_stds.append(np.insert(std_map[fair_key], 0, 0))

        objects = plt_keys
        y_pos = np.arange(0, 6)
        performance = plt_values
        ax = plt.subplot(111)
        colors = ['r', 'b', 'g', 'k', 'm']
        for i in range(len(objects)):
            print(y_pos)
            print(plt_values[i])
            if "_" in plt_keys[i]:
                label = plt_keys[i].split("_")[1]
                ls = "--"
            elif "fair" in plt_keys[i]:
                ls = "-"
                label=plt_keys[i]
            else:
                label = plt_keys[i]
                ls = '--'

            ax.errorbar(y_pos, plt_values[i], yerr=plt_stds[i], marker='o', markersize=4,
                        linestyle=ls, label=label, c = colors[int(i/2)])
        tick_label = list()
        for ti in range(0, 26, 5):
            tick_label.append(str(ti))
        plt.xticks(y_pos, tick_label)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        plt.title("Adaptation with the feedbacks")
        plt.legend(ncol=2)
        # plt.show()
        plt.savefig(os.path.join("./results", opts.prefix + "-" + str(s_yr) + suffix + "-adaptation.pdf"))
        plt.close()

    else:
        for s_yr in range(starting_yr, ending_yr):
            plt_keys = list()
            plt_values = list()
            plt_stds = list()
            fair_key = str(s_yr) + "_" + str(s_yr) + "_fair_eval" + suffix
            data = result_map[str(s_yr) + "_" + str(s_yr) + suffix][0]
            plt_values.append(np.insert(result_map[fair_key], 0, data))
            plt_stds.append(np.insert(std_map[fair_key], 0, 0))
            plt_keys.append("fair")

            optmst_key = str(s_yr) + "_" + str(s_yr) + "_optmst_eval" + suffix
            plt_values.append(np.insert(result_map[optmst_key], 0, data))
            plt_keys.append("optmst")
            plt_stds.append(np.insert(std_map[fair_key], 0, 0))
            for e_yr in range(s_yr + 1, ending_yr):
                res_key = str(s_yr) + "_" + str(e_yr) + suffix
                if res_key in keys:
                    print(res_key, result_map[res_key])
                    n_key_res = len(result_map[res_key])
                    plt_keys.append(res_key.replace(suffix, ""))
                    plt_values.append(result_map[res_key])
                    plt_stds.append(std_map[res_key])

            objects = plt_keys
            y_pos = np.arange(0, 6)
            performance = plt_values
            ax = plt.subplot(111)
            w = 0.1
            # plt_values_np = np.array(plt_values)
            # plt_stds_np = np.array(plt_stds)
            # print(plt_values_np)


            for i in range(len(objects)):
                print(y_pos)
                print(plt_values[i])
                if "_" in plt_keys[i]:
                    label = plt_keys[i].split("_")[1]
                    ls = "-"
                else:
                    label = plt_keys[i]
                    ls = '--'

                ax.errorbar(y_pos, plt_values[i], yerr=plt_stds[i], marker='o', markersize=4,
                linestyle=ls, label=label)
            # for i in range(0, n_key_res):
            #     adjusted_x = i - (n_key_res/2)
            #     ax.errorbar(y_pos + adjusted_x * w, plt_values_np[:, i], align='center', width=w, yerr=plt_stds_np[:, i])
            #     print(plt_values_np[:, i])
            tick_label = list()
            for ti in range(0, 26, 5):
                tick_label.append(str(ti))
            plt.xticks(y_pos, tick_label)
            plt.xlabel(x_label)
            plt.ylabel(y_label)
            plt.title(title + str(s_yr))
            plt.legend()
            plt.show()
            # plt.savefig(os.path.join("./results", opts.prefix + "-" + str(s_yr) + suffix + "-feedback.pdf"))
            # plt.close()


def plot_results():

    start = time.time()
    opts = parse_arguments()

    opts = process_options(opts)
    configure_logger(opts)

    print(opts.save_results_location)
    f1_mean, f1_std = collect_results(opts, f1=True)
    adr_mean, adr_std = collect_results(opts, adr=True)
    collect_results(opts, queried=True)

    # plot_map(opts, f1_mean, f1_std, f1=True)
    # plot_map(opts, adr_mean, adr_std, adr=True)
    plot_feedback(opts, adr_mean, adr_std, adr=True, adapt=True)
    plot_feedback(opts, f1_mean, f1_std, f1=True, adapt=True)

    end = time.time()
    logger.debug("##Finished all %d runs in %.2f min(s)##" % (opts.n_runs, (end - start) / 60.0))


def multi_plot_results():
    """When we want to compute results acorss different experiment settings"""
    opts = parse_arguments()

    if opts.vary_param == 0:
        param_change="weight"
    elif opts.vary_param == 1:
        param_change="independent"
    elif opts.vary_param == 2:
        param_change="feedbacked"

    f1_mean_map = {}
    f1_std_map = {}
    adr_mean_map = {}
    adr_std_map = {}

    if opts.vary_param == 0:
        list_of_params = [0, 1]

        for i in list_of_params:
            opts.weighted_update = i
            key = "W-" + str(opts.weighted_update)
            opts = process_options(opts)
            f1_mean, f1_std = collect_results(opts, f1=True)
            adr_mean, adr_std = collect_results(opts, adr=True)
            line_plt_map(f1_mean, key)
            f1_mean_map[key] = f1_mean
            f1_std_map[key] = f1_std
            adr_mean_map[key] = adr_mean
            adr_std_map[key] = adr_std
        plt.show()
        print(f1_mean_map)

def line_plt_map(map, prefix=None, plot=None):
    param_keys = map.keys()
    for pkey in param_keys:
        res_map = map[pkey]
        res_keys = res_map.keys()
        for key in res_keys:
            plt.plot(map[key], label=prefix + key)
    plt.legend()
    plt.show()


if __name__ == '__main__':
    plot_results()
    # multi_plot_results()